`timescale 1ns/1ps

module tb_serial_master;

    // -----------------------------
    // Testbench signals
    // -----------------------------
    reg        clk;
    reg        rst_n;
    reg        start;
    reg  [7:0] tx_data;
    wire       scl;
    wire       sda;
    wire       done;
    wire       error;
    wire       intr;

    // -----------------------------
    // Slave open-drain control
    // -----------------------------
    reg slave_oe;

    // Slave only pulls SDA LOW
    assign sda = slave_oe ? 1'b0 : 1'bz;
    pullup(sda);

    // -----------------------------
    // DUT
    // -----------------------------
    serial_master dut (
        .clk     (clk),
        .rst_n   (rst_n),
        .start   (start),
        .tx_data (tx_data),
        .scl     (scl),
        .sda     (sda),
        .done    (done),
        .error   (error),
        .intr    (intr)
    );

    // -----------------------------
    // Clock (100 MHz)
    // -----------------------------
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // -----------------------------
    // SCL edge detect
    // -----------------------------
    reg scl_d;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            scl_d <= 1'b1;
        else
            scl_d <= scl;
    end

    wire scl_posedge =  scl & ~scl_d;
    wire scl_negedge = ~scl &  scl_d;

    // -----------------------------
    // Simple slave ACK logic
    // -----------------------------
    reg [3:0] bit_cnt;
    reg active;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            bit_cnt  <= 0;
            active   <= 0;
            slave_oe <= 0;
        end else begin

            // START detection: SDA low while SCL high
            if (scl && sda === 1'b0 && !active) begin
                active  <= 1'b1;
                bit_cnt <= 0;
            end

            // STOP detection: SDA high while SCL high
            if (scl && sda === 1'b1 && active) begin
                active   <= 1'b0;
                slave_oe <= 1'b0;
            end

            if (active) begin
                // Count bits
                if (scl_posedge)
                    bit_cnt <= bit_cnt + 1'b1;

                // Drive ACK on 9th bit
                if (bit_cnt == 8 && scl_negedge)
                    slave_oe <= 1'b1;

                // Release ACK after sample
                if (bit_cnt == 9 && scl_negedge) begin
                    slave_oe <= 1'b0;
                    bit_cnt  <= 0;
                end
            end
        end
    end

    // -----------------------------
    // Test sequence
    // -----------------------------
    initial begin
        rst_n = 0;
        start = 0;
        tx_data = 8'h00;

        #50 rst_n = 1;

        // Test
        tx_data = 8'hF;
        #20 start = 1;
        #10 start = 0;

        wait (done || error);

        if (done && !error)
            $display("TEST PASS");
        else
            $display("TEST FAIL");

        #100 $finish;
    end

    // -----------------------------
    // Waveform
    // -----------------------------
    initial begin
        $dumpfile("waves.vcd");
        $dumpvars(0, tb_serial_master);
    end

endmodule
